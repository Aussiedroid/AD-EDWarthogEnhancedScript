//--------------------------------------------------------------------------------------------------------------------------------------------------------------//
// FUNCTIONS: TOC	//							// FUNCTIONS Include logic to customise specific Button/Toggle functionality									//
//--------------------------------------------------------------------------------------------------------------------------------------------------------------//
//		[1. FIRE/HARDPOINT CONTROLS			]	[3. SPECIALISED FEATURES				]	[4. TOGGLE CONTROLS					]	[5. REPORT STATES		  ] //
//			- initHardpointManagement	(p11)		- initLEDController				(p111)		- initEnhancedFAOFF			(p222)		- initPrintState (p555)	//
//			- initSetCombinedFire		(p11)		- initNightVisionEnhancer		(p111)		- initToggleRotationCorrect.(p222)								//
//			- initExplorerScannerDiseng.(p11)		- initAPEngageEnhancer			(p111)		- initToggleSilentRunning	(p222)								//
//													- initIDLEMaster				(p111)		- initToggleCargoScoop		(p222)								//
//													- initUserHotSlotPinkyTrigger	(p111)		- initCargoReturnMode		(p222)								//
//		[2. PIP & TEXT CHAT CONTROLS		]		- initHeadlookModeSelect		(p111)		- initToggleLandingGear		(p222)								//
//			- initPIPMapper				(p11)													- initToggleShipLights		(p222)								//
//			- initSendChatString		(p11)													- initMicCommander			(p222)								//
//--------------------------------------------------------------------------------------------------------------------------------------------------------------//
// 1. FUNCTIONS: FIRE & HARDPOINT CONTROLS //
//--------------------------------------------------------------------------------------------------------------------------------------------------------------//

	int initHardpointManagement() {																// FUNCTION: Manage Hardpoint Deployment & Associated Menu Mappings
		if(Joystick[S4] & !Joystick[H4P]) {														// This check forces Hardpoints to be deployed so Escape Vector is always in the right state. 
			initEscapeVector();	}																// Disengage & Escape Vector Macro
		if(Joystick[H4P] & !Joystick[S4]) {
			ActKey(KEYON+PULSE+UIEscape); }														// EXIT to MENU (Hold Modifier 2)
		if(Joystick[H4P] & Joystick[S4]) {
			ActKey(KEYON+PULSE+mFastModeSwitch); }												// EXIT to MENU + Fast Game Mode Switch (Hold Modifier 1+2)
		if(!Joystick[H4P] & !Joystick[S4]) {													// Standard Hardpoint Deploy/Retract
			if(!StartupLock) {
				ActKey(KEYON+PULSE+DeployHardpoints);											// If in Ship: Deploy/Retract Hardpoints
				ActKey(KEYON+DOWN+ShowCQCScoreboard); }	} }										// If in CQC: Show Scoreboard (Hold)



	int initSetCombinedFire(int toggleValue) { 													// FUNCTION: Calculate Combined Fire Status (Default = ON (Combined))
		if(toggleValue) {																		// When disabled, Trigger 2 is independant on Pinky Button (DX3) only
			combinePriSecFire = !combinePriSecFire;	}
		if(combinePriSecFire){
			if(!StartupLock & VerboseOutput) printf("Dual-Stage Trigger: Set to COMBINED Primary + Secondary Fire\x0a");
			MapKey(&Joystick, TG2, CHAIN(PrimaryFire, SecondaryFire)); }
		else {
			if(!StartupLock & VerboseOutput) printf("Dual-Stage Trigger: Set to SEPARATE Fire\x0a");
			MapKey(&Joystick, TG2, 0); } }



	int initExplorerScannerDisengage() {														// FUNCTION: Simply Defers Print Out of Explorer-Scanner Release
		if(!StartupLock) {																		//	[Gets around the no EXEC in EXEC limitation]
			if(Joystick[TG1] & VerboseOutput) DeferCall(ScanTimer, &ActKey, KEYON+PULSE+EXEC("printf(\"Repeater Fire: EXPLORER-SCANNER [OFF] (PRIMARY)\\x0a\");"));
			if(Joystick[S3]  & VerboseOutput) DeferCall(ScanTimer, &ActKey, KEYON+PULSE+EXEC("printf(\"Repeater Fire: EXPLORER-SCANNER [OFF] (SECONDARY)\\x0a\");")); } }


//--------------------------------------------------------------------------------------------------------------------------------------------------------------//
// 2. FUNCTIONS: PIP & TEXT CHAT CONTROLS //														// HAT SWITCHES
//--------------------------------------------------------------------------------------------------------------------------------------------------------------//

	int initPIPMapper(int maxPIPx=0, int minPIPy=0, int balPIPz=0) {							// FUNCTION: Sets Auto-PIP Mapping & then Sends Keystrokes   (Max, Min, Bal)
		int PIPx, PIPy, PIPz;																	// Parameters = SYS, ENG, WEP, MID		(See AD_EDSettings file)

		if		(maxPIPx == 0) 	 PIPx = 0;														// maxPIPx gets 4 PIPs (balanced 1 PIP on others if no 2nd parameter set)
		else if (maxPIPx == SYS) PIPx = PULSE+PowerSys;
		else if (maxPIPx == ENG) PIPx = PULSE+PowerEng;
		else if (maxPIPx == WEP) PIPx = PULSE+PowerWep;

		if 		(minPIPy == 0)	 PIPy = 0;														// minPIPy gets 2 PIPs
		else if (minPIPy == SYS) PIPy = PULSE+PowerSys;
		else if (minPIPy == ENG) PIPy = PULSE+PowerEng;
		else if (minPIPy == WEP) PIPy = PULSE+PowerWep;

		if 		(balPIPz == 0)	 PIPz = 0;														// balPIPz overrides minPIPy and sets 3 PIPs each 'balanced' for max & min PIPs
		else if (balPIPz == MID) PIPz = PIPy;

		if(!StartupLock) {
			ActKey(KEYON+CHAIN(																	// MACRO: Send PIP Configuration
				PULSE+BalancePower, D(),														// If NO other parameters set, only Balance Power
				PIPx, D(),
				PIPy, D(),
				PIPx, D(),
				PIPx, D(),
				PIPz));	} }


																								// FUNCTION: Send String of Predefined Characters to Cockpit Comms Panel
	int initSendChatString(alias string) {														//           [NOTE 1: Set ChatPresetMode in the AD_EDSettings file]
		int length, pos = 0;																	// 			 [NOTE 2: LOCK function does not work with this, so if you press a button which sends keys to the game whilst the routine is typing into the chat window, these will get inserted into the text stream and will not go to the game.]

		length = strlen(&string);																// Determine Length of the Chat String (used to set number of loops needed in while statement below)

		ActKey(KEYON+PULSE+mChatPanelGrab);														// PANEL RESET
		strsub(&ca_pulseChar, &string, pos, pos);												// FIRST CHAR:		Before Entering Loop, Set String Value and..
		ActKey(KEYON+PULSE+ca_pulseChar[0]); 		pos = pos + 1;								// 					..Pulse First Keypress without Delay (Prevents issues with Capitals 'sticking' for first letters)
		while (pos < length) {																	// REMAINING CHARS:	WHILE there are characters to output, loop.
			strsub(&ca_pulseChar, &string, pos, pos);											// 					Update pulseChar key
			DeferCall(ChatKeyRepeatTime * (pos + 1), &ActKey, KEYON+PULSE+ca_pulseChar[0]);		// 					Output pulseChar key to Comms Panel
			pos = pos + 1;   }																	// 					Next character/key
		DeferCall(ChatKeyRepeatTime * (pos + 2), &ActKey, KEYON+PULSE+QuickCommsPanel);			// Prepare to Close Text Box/Comms
		Sleep(250); DeferCall(ChatKeyRepeatTime * (pos + 2), &ActKey, KEYON+PULSE+CommsPanel);	// CLOSE Comms Panel (+UI Delay - Default: 250ms)
		if(VerboseOutput) { printf("Comms Auto-Text  :SENT:  \"");		printf(&string);		printf("\" \x0a"); } } // Display Full Chat String to TARGET Output Panel


//--------------------------------------------------------------------------------------------------------------------------------------------------------------//
// 3. FUNCTIONS: SPECIALISED FEATURES //
//--------------------------------------------------------------------------------------------------------------------------------------------------------------//

	int initLEDController(int x) {																// FUNCTION: LED Controller provides flashing LED feedback on Toggle switching & will initiate a startup up sequence patter for LEDs when script starts.
		int counter = 0;																		// [Set BlingLEDBling=1 in User Preferences to Enable Function]
		if(!StartupLock) {
			while (counter < 6) {																// Flash LED Sequencer (Approx 3 times) (Change counter value & counter*xx in Defercall to change timings/duration) (Default values are 6 and 60)
				DeferCall(counter*60, &ActKey, KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT^x));	// Usage example: if(BlingLEDBling) initLEDController(LED1);
				counter = counter + 1;	} }
		else {																					// Startup LED Sequencer (This will leave LED 1 & 2 active for FAOFF & Rotational Correction at end of script launch)
			ActKey(PULSE+KEYON+LED(&Throttle, LED_INTENSITY, SetLED)); 							// Enable LED Backlight on Start & then Initiate LED status below:
			ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT-LED1));					// Disable any active LEDs 1-5, Ready For Sequencing.
			ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT-LED2));
			ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT-LED3)); 					// set LED 3 OFF 	[Silent Running]
			ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT-LED4)); 					// set LED 4 OFF	[Cargo Scoop]
			ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT-LED5)); 					// set LED 5 OFF	[Landing Gear]
			ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT+LED1));					// Start Sequence
			ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT+LED2));	Sleep(20);
			ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT+LED3));
			ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT-LED1));	Sleep(33);
			ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT+LED4));
			ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT-LED2));	Sleep(33);
			ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT+LED5));
			ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT-LED3));	Sleep(33);
			ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT-LED4));	Sleep(120);		// End of Reverse Sequence
			ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT+LED4));	Sleep(33);
			ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT+LED3));
			ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT-LED5));	Sleep(33);
			ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT+LED2));
			ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT-LED4));	Sleep(33);
			ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT+LED1)); 					// set LED 1 ON 	[Flight Assist]
			ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT-LED3));	Sleep(33);
			ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT-LED2));	Sleep(20);
			ActKey(PULSE+KEYON+LED(&Throttle, LED_ONOFF, LED_CURRENT+LED2));	} }				// set LED 2 ON 	[Rotational Correction]
																								// End of Forward Sequence


	int initNightVisionEnhancer() { 															// FUNCTION: Calculate Night Vision state.
		fnProcessFlags();																		// Get latest Flags Value first
		ActKey(KEYON+PULSE+NightVision);
		if(NightVisionHUD) ActKey(KEYON+PULSE+HideShipGUI);										// If enabled in User Preferences, Hide the Ship/SRV HUD when enabling Night Vision.
		if(!fDocked) { 
			if(!fNightVision){																	// Dims Throttle LED Backlight intensity when active.
				if(VerboseOutput) printf("Night Vision: ^^ ACTIVE ^^\x0a");
				ActKey(KEYON+PULSE+LED(&Throttle, LED_INTENSITY, 50)); }						// Dim Throttle Lights
			else  {
				if(VerboseOutput) printf("Night Vision: DEACTIVATED\x0a");
				ActKey(KEYON+PULSE+LED(&Throttle, LED_INTENSITY, 172)); } }						// Return Throttle Lights to Default
		else {
			ActKey(KEYON+PULSE+LED(&Throttle, LED_INTENSITY, 172));
			if(VerboseOutput) printf("Night Vision: DISABLED WHILE DOCKED\x0a"); } }


																								// FUNCTION: User Definable Autopilot Engage Button providing a total of Six inputs; a Short & Long Press option for Standalone, Pinky Modifier & CMS Hat Modifier combinations.
	int initAPEngageEnhancer() { 																//	(See AD_EDUserPrefs.tmh for mappings)
		fnProcessFlags();																		// Get latest Flags Value first
		if(Joystick[H4P]) {																		//	 Defaults: Include the Autodock, Signal Light Sequences (Flashing ShipLights) & Basic Text Comms.
			if(APSeqShort) {																	// [Short+CMS: Text "CMDR o7" (default)]
				ActKey(KEYON+PULSE+APEngageCMSShort);											// Set custom APEngageCMSShort value in the User Preferences
				APSeqShort=!APSeqShort; }
			if(APSeqLong) {																		// [Long+CMS: Text "Fly Safe CMDR" (default)]
				ActKey(KEYON+PULSE+APEngageCMSLong);											// Set custom APEngageCMSLong value in the User Preferences
				APSeqLong=!APSeqLong; } }
		if(Joystick[S4]) {
			if(APSeqShort) {																	// [Short+Pinky: Auto-Dock Request (default)]
				if(mRequestDock & fDocked) {
					if(VerboseOutput) printf("Cannot Auto-Dock when Docked!"); }
				else { ActKey(KEYON+PULSE+APEngagePinkyShort);	}										// Set custom APEngagePinkyShort value in the User Preferences
				if(APEngagePinkyShort == mRequestDock & VerboseOutput & !fDocked) printf("Attempting Auto-Dock Procedure...\x0a");
				if(APEngagePinkyShort == mHangarAutomation & VerboseOutput & fDocked) printf("Repair & Refuel Sequence Activated...\x0a");
				APSeqShort=!APSeqShort; }
			if(APSeqLong) {																		// [Long+Pinky: Auto-Dock Request (default)]
				if(mHangarAutomation & !fDocked) {
					if(VerboseOutput) printf("Cannot Repair & Refuel when not Docked!"); }
				else { ActKey(KEYON+PULSE+APEngagePinkyLong);	}	
				ActKey(KEYON+PULSE+APEngagePinkyLong);											// Set custom APEngagePinkyLong value in the User Preferences
				if(APEngagePinkyLong == mRequestDock & VerboseOutput & !fDocked) printf("Attempting Auto-Dock Procedure...\x0a");
				if(APEngagePinkyLong == mHangarAutomation & VerboseOutput & fDocked) printf("Repair & Refuel Sequence Activated...\x0a");
				APSeqLong=!APSeqLong; } }
		if(!Joystick[S4] & !Joystick[H4P]) {
			if(APSeqShort) {																	// [Short: Short Signal Light Sequence (default)]
				ActKey(KEYON+PULSE+APEngageShort);												// Set custom APEngageShort value in the User Preferences
				if(APEngageShort == mSignalLights & VerboseOutput) printf("Lights: ^ SHORT SIGNAL SEQUENCE ACTIVATED ^\x0a");
				APSeqShort=!APSeqShort; }
			if(APSeqLong) {																		// [Long: Long Signal Light Sequence (default)]
				ActKey(KEYON+PULSE+APEngageLong);												// Set custom APEngageLong value in the User Preferences
				if(APEngageLong == mSignalLightsLong & VerboseOutput) printf("Lights: ^ LONG SIGNAL SEQUENCE ACTIVATED ^\x0a");
				APSeqLong=!APSeqLong; } } }



	int initIDLEMaster() {																		// FUNCTION: Enforce Throttle IDLE (Stationary) on any Throttle Mode
		if(!StartupLock) {
			fnProcessFlags();																		// Get latest Flags Value first
			if(Throttle[IDLELON]) {
				if(!Throttle[FLAPU]) {															// Resets Throttle Axis to 0 for Full Range Throttle Modes
					DXAxis(DX_ZROT_AXIS, 0);													// Prevents issues launching from stations etc
					DXAxis(DX_Z_AXIS, 0);
					LockAxis(&Throttle, THR_LEFT, 1);											// Lock Axes to keep null value
					LockAxis(&Throttle, THR_RIGHT, 1);
					if(fSRV) ActKey(KEYON+PULSE+SRVHandbrake); }											// IDLE Doubles as SRV Handbrake ON when on surface
				if(Throttle[FLAPU]) {															// Resets Throttle Axis to 0 for Forward Only Throttle Mode
					DXAxis(DX_ZROT_AXIS, 32767);
					DXAxis(DX_Z_AXIS, 32767);
					LockAxis(&Throttle, THR_LEFT, 1);											// Lock Axes to keep null value
					LockAxis(&Throttle, THR_RIGHT, 1);
					if(fSRV) ActKey(KEYON+PULSE+SRVHandbrake); }	}										// IDLE Doubles as SRV Handbrake ON when on surface
			if(!Throttle[IDLELON]) {
				LockAxis(&Throttle, THR_LEFT, 0);												// Unlocks the Throttle Axes when exiting IDLE
				LockAxis(&Throttle, THR_RIGHT, 0);
				if(fSRV) ActKey(KEYON+PULSE+SRVHandbrake); } } }											// Release the SRV Handbrake
	


	int initUserHotSlotPinkyTrigger() {															// FUNCTION: Enables User Definable 'Double Tap' functionality on the Pinky Trigger [S4]
		if(!StartupLock) {																		// *This line is only required to prevent running on startup
			if(DoubleTapPT == 0) {																// IF Single (First) Press  (DoubleTapPT starts at 0)
				ActKey(KEYON+DOWN+PinkyTriggerDefault);											// Trigger Standard DX4/JOY 4 mapping
				DoubleTapPT = 1;																// Increment DoubleTapPT counter
				DeferCall(DTPressDelay, &ActKey, KEYON+PULSE+EXEC("DoubleTapPT = 0;")); }		// Sets Double Tap Speed: After delay of 365ms, reset DoubleTapPT counter to 0 (This is your window to press Pinky Trigger again for double tap) 
			else if(DoubleTapPT == 1) {															// IF Double (Second) Press
				DoubleTapPT = 2;																// Increment DoubleTapPT counter (prevents further triggers until DoubleTapPT delay timer cycle completes)
				ActKey(KEYON+PULSE+UserDTPinkyKeyBind); } } }									// Trigger User Hot Slot Preference (*see User Preferences to set*)
//				ActKey(KEYON+DOWN+UserDTPinkyKeyBind); } } }									// ALTERNATE Config (enable if Double Tap Pinky Trigger needs a Hold action - remember to disable the line above!)



	int initHeadlookModeSelect() {																// FUNCTION: Choose Headlook Center Method, based on hardware preference
		if(!StartupLock) {
			if(HeadtrackPref == 0) {															// 			(Maps to the Engine Operate Ign/Norm LEFT UP)
				if(!Joystick[S4]) ActKey(KEYON+PULSE+LookCenter);								// [Short:		 Headlook Center Toggle] 	[MOUSE]
				if(Joystick[S4])  ActKey(KEYON+PULSE+ToggleVoiceAttackGlobal); }				// [Short+Pinky: VA Toggle]
			if(HeadtrackPref == 1) {
				if(!Joystick[S4]) ActKey(KEYON+PULSE+TrackIRCenter);							// [Short: 		 TIR Center]				[TRACKIR/TOBI EYE/EDTRACKER]
				if(Joystick[S4])  ActKey(KEYON+PULSE+ToggleVoiceAttackGlobal); }				// [Short+Pinky: VA Toggle]
			if(HeadtrackPref == 2) {
				if(!Joystick[S4]) ActKey(KEYON+PULSE+ResetHMDOrientation);						// [Short: 		 Reset HMD Orientation]		[VR/VIVE/OCCULUS RIFT]
				if(Joystick[S4])  ActKey(KEYON+PULSE+ToggleVoiceAttackGlobal); } } }			// [Short+Pinky: VA Toggle]


//--------------------------------------------------------------------------------------------------------------------------------------------------------------//
// 4. FUNCTIONS: TOGGLE CONTROLS //
//--------------------------------------------------------------------------------------------------------------------------------------------------------------//

	int initEnhancedFAOFF() {																	// FUNCTION: Enhanced Joystick Curves tailored for Flight Assist Off (TOGGLE)
		fnProcessFlags();																		// Get latest Flags Value first
		if(Throttle[SPDF]) {																	//    AKA     "FAOFF LIKE A BOSS!"
			if(Joystick[S4]) {																	// FA OFF: TOGGLE
				ActKey(KEYON+PULSE+AlternativeFlightMode);										// Enables Alternative Flight Control Mappings (when using the Pinky Trigger).
				AltFlightToggle = 1; }
			if(!Joystick[S4] & !fFAOff) {
				ActKey(KEYON+PULSE+FlightAssist);
				SetSCurve(&Joystick, JOYX, 0, 1, 0, 2, -1);										// Reduces the Joystick sensitivity on Forward TOGGLE on FA Off
				SetSCurve(&Joystick, JOYY, 0, 1, 0, 2, -1);										// Full Joystick sensitivity remains on Back HOLD on FA Off for quick turns in combat
				if(UseRuddersTPR & UseRudderAxisCurves)		SetSCurve(&TFRPHARudder, TRUDDER, 0, 10, 0, 3, -1);
				if(UseRuddersT16000 & UseRudderAxisCurves)	SetSCurve(&TFRPRudder, TFRPHA_RUDDER, 0, 10, 0, 3, -1);
				ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT-LED1));				// set LED 1 OFF
				if(BlingLEDBling) initLEDController(LED1);
				if(UseRudderAxisCurves & VerboseOutput)  printf("Joystick Profile[%d]: Yaw=%d, Curve=%d, Zoom=%d\x0a", profile, YAW_CURVE[profile], JS_CURVE[profile], JS_ZOOM[profile]);
				if(!UseRudderAxisCurves & VerboseOutput) printf("Joystick Profile[%d]: Curve=%d, Zoom=%d\x0a", profile, JS_CURVE[profile], JS_ZOOM[profile]); } }
		if(!Throttle[SPDF]) {
			if(AltFlightToggle) {
				ActKey(KEYON+PULSE+AlternativeFlightMode);										// Disables Alternative Flight Control Mappings (works with both Pinky Trigger & Without!).
				AltFlightToggle=!AltFlightToggle; }
			if(fFAOff) {
				ActKey(KEYON+PULSE+FlightAssist);
				initSetJoystickCurves();														// Return Joystick Curve back to previous preset (based on toggle position)
				if(BlingLEDBling) initLEDController(LED1);
				ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT+LED1));				// set LED 1 ON     you will need to toggle back to center, then UP/DOWN again to reapply settings.
				if(UseRudderAxisCurves & VerboseOutput)  printf("Returning to Joystick Profile [%d]: Yaw=%d, Curve=%d, Zoom=%d\x0a", profile, YAW_CURVE[profile], JS_CURVE[profile], JS_ZOOM[profile]);
				if(!UseRudderAxisCurves & VerboseOutput) printf("Returning to Joystick Profile [%d]: Curve=%d, Zoom=%d\x0a", profile, JS_CURVE[profile], JS_ZOOM[profile]);  } }
		if(Throttle[SPDB]) {																	// FA OFF: HOLD
			if(Joystick[S4]) {
				ActKey(KEYON+PULSE+AlternativeFlightMode);
				AltFlightHold = 1; }
			if(!Joystick[S4] & !fFAOff) {
				ActKey(KEYON+PULSE+FlightAssist);
				ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT-LED1)); } }			// set LED 1 OFF
		if(!Throttle[SPDB]) {
			if(AltFlightHold) {
				ActKey(KEYON+PULSE+AlternativeFlightMode);										// Disables Alternative Flight Control Mappings (works with both Pinky Trigger & Without!).
				AltFlightHold=!AltFlightHold; }
			if(fFAOff) {
				ActKey(KEYON+PULSE+FlightAssist);
				ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT+LED1)); } } }			// set LED 1 ON



	int initToggleRotationCorrection() {														// TOGGLE: Rotational Correction
		if(Throttle[EORMOTOR]) {																// Default: ON (Position toggle switch DOWN to disable)
			if(!RCorrection) {																	// Press 'F4' to toggle manually if misaligned, or change in Sys Panel.
				RCorrection = 1;
				if(!StartupLock & VerboseOutput) printf("Rotation Correction: DISABLED !!\x0a");
				ActKey(KEYON+PULSE+RotationalCorrection);
				if(BlingLEDBling) initLEDController(LED2);
				ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT-LED2)); } }			// set LED 2 OFF
		if(!Throttle[EORMOTOR]) {
			if(RCorrection) {
				RCorrection = 0;
				if(!StartupLock & VerboseOutput) printf("Rotation Correction: ENABLED  ^^\x0a");
				if(!StartupLock)  ActKey(KEYON+PULSE+RotationalCorrection);
				if(BlingLEDBling) initLEDController(LED2);
				ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT+LED2)); } } }			// set LED 2 ON



	int initToggleSilentRunning(int x) {														// TOGGLE: Silent Running   (Argument x .. 1 = Deploy, 0 = Retract)
        fnProcessFlags();																		// Get latest Flags Value first
        if (!fSupercruise & !fSRV & !fLanded & !fDocked) {						// Only attempt to toggle landing gear if we're not in Supercruise, in SRV, Landed or Docked
            if (fSilentRunning != x) {															// Only DEPLOY or RETRACT if landing gear status does NOT match the action we asked for. ie. DEPLOY only when RETRACTED and vice-versa
				ActKey(KEYON+PULSE+SilentRunning);												// [Toggle Hold]
				if(Joystick[S4] & Throttle[APUON])  {											// Heat Sink + Silent Running Combo [Pinky+Silent Running]
					CoolRunnings=!CoolRunnings;
					ActKey(KEYON+PULSE+EXEC("initPIPMapper(ENG,WEP);"));						// Set PIPs to ENGx4 WEPx2 - Offensive stance - removes from SYS
					ActKey(KEYON+PULSE+DeployHeatSink);
					ActKey(KEYON+PULSE+SilentRunning);
					if(VerboseOutput) printf("Silent Running: COOL RUNNINGS (!Heat Sink Combo!)\x0a"); }
                if (!fSilentRunning) {    // OPEN ACTIONS //
                	if(BlingLEDBling) initLEDController(LED3);
					ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT+LED3));				// set LED 3 ON
                	if(!StartupLock & VerboseOutput) printf("Silent Running: ACTIVATED   !!\x0a"); }				// Print the action to console...
                else {					 // CLOSE ACTIONS //
                	ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT-LED3));				// set LED 3 OFF
					if(BlingLEDBling) initLEDController(LED3);
					if(CoolRunnings) {
									CoolRunnings=!CoolRunnings;
									ActKey(KEYON+PULSE+EXEC("initPIPMapper(SYS,WEP);")); }			// Set PIPs to SYSx4 WEPx2 - Offensive stance - removes from SYS
                    if(!StartupLock & VerboseOutput) printf("Silent Running: DEACTIVATED <<\x0a");	 } }
            else {
                if(!StartupLock & VerboseOutput) printf("Silent Running: NOTHING TO DO ==\x0a"); } }
        else {																					// ... or, print the reason no action taken
            if (fSupercruise) {		  printf("Silent Running: DISABLED WHILST IN SUPERCRUISE\x0a"); }
            if (fSRV) {				  printf("Silent Running: DISABLED WHILST IN SRV\x0a"); }
            if (fLanded | fDocked) {  printf("Silent Running: DISABLED WHEN LANDED\x0a"); } } }



	int initToggleCargoScoop(int x) {															// TOGGLE: Cargo Scoop   (Argument x .. 1 = Deploy, 0 = Retract)
		fnProcessFlags();																		// Get latest Flags Value first
		if (!fSupercruise & !fLanded & !fDocked) {		//  & !StartupLock						// Only attempt to toggle landing gear if we're not in Supercruise and not Landed or Docked.
			if (fCargoScoop != x) {																// Only DEPLOY or RETRACT if landing gear status does NOT match the action we asked for. ie. DEPLOY only when RETRACTED and vice-versa.
				if(!Joystick[S4] & !Joystick[H4P]) { 
					ActKey(KEYON+PULSE+CargoScoop); }											// TRIGGER Cargo Scoop (When no Modifier Held).
				if(Joystick[S4] &  !Joystick[H4P] & Throttle[RDRNRM]) {											// TOGGLE PRECISION MODE: If CMS Hat Switch + Toggle, then Throttle Precision Mode when Cargo Scoop is Open.
					CargoPrecisionMode=!CargoPrecisionMode;
					if(CargoPrecisionMode) {	// ENABLE CPM //								// ENABLE PRECISION MODE: If Precision Mode is ON, then limit Throttle axis to 50% (Blue Zone).
						ActKey(KEYON+PULSE+CargoScoop);
						TrimDXAxis(DX_Z_AXIS, SET(0));
						SetSCurve(&Throttle, THR_RIGHT, 0, 2, 0, 2, -2);
						if(VerboseOutput) printf("Cargo Scoop Precision Mode: ENABLED -> OVERRIDE PRECISION [-50 -> 50]\x0a");
						SetThrottle(); }
					else {						// DISABLE CPM //
						initCargoReturnMode(); } }												// MANUAL DISABLE PRECISION MODE: Returns Throttle range to your default (as set in your User Prefs).
				if(Joystick[S4] &  !Joystick[H4P] & !Throttle[RDRNRM]) {					
					ActKey(KEYON+PULSE+CargoScoop);
					initCargoReturnMode(); }
				if(Joystick[S4] & Joystick[H4P] & !Throttle[RDRNRM]) {							// JETTISON ALL CARGO: If BOTH CMS Hat Switch & Pinky Trigger Modifier are held + Cargo Scoop is DOWN, the activate Jettison All Cargo & close Cargo Scoop.
					ActKey(KEYON+PULSE+JettisonAllCargo);
					if(VerboseOutput) printf("Cargo Scoop: JETTISON ALL CARGO !!\x0a");
					DeferCall(5000, &ActKey, KEYON+PULSE+CargoScoop); }
                if(!fCargoScoop) { 			// OPEN ACTIONS //
                	if(BlingLEDBling) initLEDController(LED4);
					ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT+LED4));			// set LED 4 ON
                	if(VerboseOutput) printf("Cargo Scoop: DEPLOYED >>\x0a"); }
                else {						// CLOSE ACTIONS //
                	initCargoReturnMode();														// AUTO DISABLE PRECISION MODE: Returns Throttle range to your default whenever you close Cargo Scoop (as set in your User Prefs).
                	ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT-LED4));			// set LED 4 OFF
					if(BlingLEDBling) initLEDController(LED4);
					if(VerboseOutput) printf("Cargo Scoop: RETRACTED <<\x0a"); } }
			else {																				// Toggle is currently in the wrong position.
                if(!StartupLock & VerboseOutput) printf("Cargo Scoop: NOTHING TO DO ==\x0a"); } }
        else {																					// BLOCKED From Action.
            if (fSupercruise) {		  printf("Cargo Scoop: DISABLED WHILST IN SUPERCRUISE\x0a"); }
            if (fLanded | fDocked) {  printf("Cargo Scoop: DISABLED WHEN LANDED\x0a"); } } }



	int initCargoReturnMode() {																	// FUNCTION: Returns Throttle to default behaviour by disabling Precision Mode or Closing Cargo Scoop.
		if(!StartupLock) {
			if(VerboseOutput) printf("Cargo Scoop Precision Mode: DISABLED <<\x0a");
			if(CargoReturnMode == 0) {															// Used only in initToggleCargoScoop();
				TrimDXAxis(DX_Z_AXIS, SET(-1024));												// Set your CargoReturnMode preference in User Prefs.
				if(CruiseOnThrottle == 0) SetSCurve(&Throttle, THR_RIGHT, 0, -100, 0, 0);
				if(CruiseOnThrottle == 1) SetSCurve(&Throttle, THR_RIGHT, 0, -90, 0, 0); 
				if(VerboseOutput) printf("Throttle Profile: CARGO SCOOP REVERT FORWARD ONLY [0 -> 100]\x0a"); }
			if(CargoReturnMode == 1) {
				TrimDXAxis(DX_Z_AXIS, SET(0));
				if(CruiseOnThrottle == 0) SetSCurve(&Throttle, THR_RIGHT, 0, 5, 0, 0);
				if(CruiseOnThrottle == 1) SetJCurve(&Throttle, THR_RIGHT, 90, 100);
				if(VerboseOutput) printf("Throttle Profile: CARGO SCOOP REVERT FULL SCALE [-100 -> 100]\x0a"); }
			if(CargoReturnMode == 2) {
				TrimDXAxis(DX_Z_AXIS, SET(0));
				SetJCurve(&Throttle, THR_RIGHT, 80, 100);
				if(VerboseOutput) printf("Throttle Profile: CARGO SCOOP REVERT FULL SCALE CUSTOM [-100 -> 80]\x0a"); }
			if(CargoReturnMode == 3) {
				TrimDXAxis(DX_Z_AXIS, SET(0));
				SetSCurve(&Throttle, THR_RIGHT, -25, 0, -25, 0);
				if(VerboseOutput) printf("Throttle Profile: CARGO SCOOP REVERT TRIMMED [-75 -> 75]\x0a"); }
			SetThrottle(); } }  



	int initToggleLandingGear(int x) {															// TOGGLE: Landing Gear   (Argument x .. 1 = Deploy, 0 = Retract)
        fnProcessFlags();																		// Get latest Flags Value first
        if (!fSupercruise & !fSRV & !fLanded & !fDocked) {		// & !StartupLock				// Only attempt to toggle landing gear if we're not in Supercruise, in SRV, Landed or Docked
            if (fLandingGear != x) {															// Only DEPLOY or RETRACT if landing gear status does NOT match the action we asked for. ie. DEPLOY only when RETRACTED and vice-versa
				if(!Joystick[S4] | (Joystick[S4] & Throttle[EACON])) {
					ActKey(KEYON+PULSE+LandingGear); }
				if(Joystick[S4] & !Throttle[EACON]) {											// Hold CMS Hat Switch to Initiate Take Off Procedure (This will hold Vert. Thrust up, toggle Landing Gear & Set PIPs for Launch at Station or Planet Surface)
					ActKey(KEYON+PULSE+EXEC("initPIPMapper(SYS,ENG);"));						// Set PIPs to SYSx4 ENGx2 - Protect Ship on Launch
					ActKey(KEYON+DOWN+ThrustUp);
					ActKey(KEYON+PULSE+SetSpeed0);
					DeferCall(3500, &ActKey, KEYON+PULSE+LandingGear);							// Retract Landing Gear shortly after leaving pad/surface
					DeferCall(4000, &ActKey, KEYON+UP+ThrustUp);								// Releases Vertical Thrust after 4 seconds
					if(VerboseOutput) printf("Landing Gear: LAUNCH SEQUENCE ACTIVATED >>\x0a"); }
                if(!fLandingGear) {  		  // OPEN ACTIONS //
                	if(BlingLEDBling) initLEDController(LED5);
					ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT+LED5));
                	if(VerboseOutput) printf("Landing Gear: DEPLOYED >>\x0a"); }
                else {						 // CLOSE ACTIONS //
                	ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT-LED5));			// set LED 5 OFF
					if(BlingLEDBling) initLEDController(LED5);
                    if(VerboseOutput) printf("Landing Gear: RETRACTED <<\x0a");	 } }
            else {
                if(VerboseOutput& !StartupLock) printf("Landing Gear: NOTHING TO DO ==\x0a"); } }
        else {																					// 
            if (fSupercruise) {		  printf("Landing Gear: DISABLED WHILST IN SUPERCRUISE\x0a"); }
            if (fSRV) {				  printf("Landing Gear: DISABLED WHILST IN SRV\x0a"); }
            if (fLanded | fDocked) {  printf("Landing Gear: DISABLED WHEN LANDED\x0a"); } } }



	int initToggleShipLights(int toggleValue) { 												// FUNCTION: Calculate ShipLights state.
		if(toggleValue) {																		// Dims Throttle LED Backlight intensity when active.
			Lights=!Lights; }																	// Note: This can get a little buggy with the SRV multiple lighting levels.
		if(Lights){																				// Press 'INSERT' to toggle manually if SRV has messed things up or extra long hold to reset.
			if(VerboseOutput) printf("Lights: ^^ ILLUMINATE! ^^\x0a");
			ActKey(KEYON+PULSE+ShipLights);
			ActKey(KEYON+PULSE+LED(&Throttle, LED_INTENSITY, 50)); }							// Dim Throttle Lights
		if(!Lights) {
			if(VerboseOutput) printf("Lights:    DELUMINATE!\x0a");
			ActKey(KEYON+PULSE+ShipLights);
			ActKey(KEYON+PULSE+LED(&Throttle, LED_INTENSITY, 172)); } }							// Return Throttle Lights to Default



	int initMicCommander() {																	// FUNCTION: Manages Microphone Internal/External Push-to-Talk buttons
		if(Throttle[MSP]) {																		// [HOLD PTT]
			MicCheckHold = 1;																	// Enable PTT Buttons
			if(Throttle[EFROVER]) {																// If Mic Toggle OFF:	Use Internal PTT Voice Comms/Open Comms
				if(ExternalMicInverse) {														// Will Invert VoiceAttack listening when Internal Comms are used
						ActKey(KEYON+PULSE+ToggleVoiceAttackGlobal);
						ActKey(KEYON+PULSE+InternalVoiceCommsPTT); }
				else {	ActKey(KEYON+PULSE+InternalVoiceCommsPTT); } }
			if(Throttle[EFRNORM]) {																// If Mic Toggle ON:	Use External PTT Voice Comms/Open Comms
			  if(ExternalMicInverse) {															// Enables Inversed External PTT Channels (Enabling Discord will Disable VoiceAttack)
				if(!MicExternalAction) {														// Check if user preference match requirements for 'ExternalMicInverse' functionality (See NOTE 2 in AD_EDSettings.tmh file)
					ActKey(KEYON+PULSE+ToggleVoiceAttackGlobal);								// 	NOTE: This will only work correctly if Listening is enabled (ALT+F2) in VoiceAttack prior to first press of the PTT button
					ActKey(KEYON+DOWN+ExternalVoiceCommsPTT);
					MicExtHoldCheck = 1; } }
			  if(!ExternalMicInverse) {															// Enables Independant External PTT Channels (Each channel separated by Pinky Trigger and can be used in any combination)
				if(!Joystick[S4]) {
					if(MicExternalAction) {														// Check if user preference for External Voice is Toggle or PTT
							ActKey(KEYON+PULSE+ExternalVoiceCommsPTT);
							MicExtPulseCheck = 1; }
					else {	ActKey(KEYON+DOWN+ExternalVoiceCommsPTT);
							MicExtHoldCheck = 1; } }
				if(Joystick[S4]) {																// If Mic Toggle ON + Pinky Trigger Held:  Use Alternative External PTT Voice Comms Open Comms
					if(MicExternalActionALT) {													// Check if user preference for Alt. External Voice is Toggle or PTT
							ActKey(KEYON+PULSE+ExternalVoiceCommsPTT_ALT);
							MicExtPulseCheckALT = 1; }
					else {	ActKey(KEYON+DOWN+ExternalVoiceCommsPTT_ALT);
							MicExtHoldCheckALT = 1; } } } } }
		if(!Throttle[MSP] & MicCheckHold) {														// [HOLD PTT]
			MicCheckHold=!MicCheckHold;															// Release PTT Buttons
			if(Throttle[EFROVER]) {																// If Mic Toggle OFF:	Release Internal PTT Voice Comms Open Comms
				if(ExternalMicInverse) {														// Will Invert VoiceAttack listening when Internal Comms are used
					ActKey(KEYON+PULSE+ToggleVoiceAttackGlobal); } }
			if(Throttle[EFRNORM]) {																
				if(MicExtPulseCheck) {															// Check if Internal, External or Alt. External was pressed, then release accordingly.
					ActKey(KEYON+PULSE+ExternalVoiceCommsPTT);									// If Mic Toggle ON:	Release External PTT Voice Comms Open Comms
					MicExtPulseCheck = 0; }
				if(MicExtPulseCheckALT) {
					ActKey(KEYON+PULSE+ExternalVoiceCommsPTT_ALT);								// If Mic Toggle ON:	Release Alternative External PTT Voice Comms Open Comms
					MicExtPulseCheckALT = 0; }
				if(ExternalMicInverse & MicExtHoldCheck) {
					ActKey(KEYON+PULSE+ToggleVoiceAttackGlobal); }								// Toggles VoiceAttack Back ON
				if(MicExtHoldCheck | MicExtHoldCheckALT) {
					ActKey(KEYON+UP+ExternalVoiceCommsPTT);										// Release HOLDS
					ActKey(KEYON+UP+ExternalVoiceCommsPTT_ALT);
					MicExtHoldCheck = 0;
					MicExtHoldCheckALT = 0; } } }
		if(Throttle[EOLMOTOR]) {																// [TOGGLE PTT]
			MicCheckToggle = 1;																	// Enable Toggle
			if(Throttle[EFROVER]) {
				if(VerboseOutput) printf("Voice Comms: ^^  INTERNAL MIC OPEN  ^^\x0a");
				ActKey(KEYON+PULSE+InternalVoiceCommsPTT); }									// If Mic Toggle OFF:	Use Internal PTT Voice Comms Open Comms
			if(Throttle[EFRNORM]) {
				if(!Joystick[S4]) {
					if(VerboseOutput) printf("Voice Comms: ^^  MAIN EXTERNAL MIC OPEN  ^^\x0a");
					if(MicExternalAction)  ActKey(KEYON+PULSE+ExternalVoiceCommsPTT);			// If Mic Toggle ON:	Use External PTT Voice Comms Open Comms
					if(!MicExternalAction) ActKey(KEYON+DOWN+ExternalVoiceCommsPTT);
					MicExtToggleCheck = 1; }
				if(Joystick[S4]) {
					if(ExternalMicCombined) {													// Check if user preference for External Voice Comms is Combined or Separate
						if(VerboseOutput) printf("Voice Comms: ^^  BOTH EXTERNAL MICS OPEN  ^^\x0a");
						MicExtToggleCombo = 1;
						if(MicExternalAction & MicExternalActionALT) {							// Depending on the user preferences, enable the correct combination of External Voice Comms
							ActKey(KEYON+PULSE+ExternalVoiceCommsPTT);
							ActKey(KEYON+PULSE+ExternalVoiceCommsPTT_ALT); }
						if(!MicExternalAction & MicExternalActionALT) {
							ActKey(KEYON+DOWN+ExternalVoiceCommsPTT);
							ActKey(KEYON+PULSE+ExternalVoiceCommsPTT_ALT); }
						if(MicExternalAction & !MicExternalActionALT) {
							ActKey(KEYON+PULSE+ExternalVoiceCommsPTT);
							ActKey(KEYON+DOWN+ExternalVoiceCommsPTT_ALT); }
						if(!MicExternalAction & !MicExternalActionALT) {
							ActKey(KEYON+DOWN+ExternalVoiceCommsPTT);
							ActKey(KEYON+DOWN+ExternalVoiceCommsPTT_ALT); }	}
					if(!ExternalMicCombined) {
						if(VerboseOutput) printf("Voice Comms: ^^  ALT EXTERNAL MIC OPEN  ^^\x0a");
						if(MicExternalActionALT)  ActKey(KEYON+PULSE+ExternalVoiceCommsPTT_ALT);// If Mic Toggle ON:  Use Alternative External PTT Voice Comms Open Comms	
						if(!MicExternalActionALT) ActKey(KEYON+DOWN+ExternalVoiceCommsPTT_ALT);
						MicExtToggleCheckALT = 1; } } } }
		if(!Throttle[EOLMOTOR] & MicCheckToggle) {												// [TOGGLE PTT]
			MicCheckToggle=!MicCheckToggle;														// Release Toggle
			if(Throttle[EFROVER]) {
				if(VerboseOutput) printf("Voice Comms: <<  INTERNAL MIC CLOSED  <<\x0a");
				ActKey(KEYON+PULSE+InternalVoiceCommsPTT); }									// If Mic Toggle OFF:	Release Internal PTT Voice Comms Open Comms
			if(Throttle[EFRNORM]) {
				if(ExternalMicCombined) {														// Check if user preference for External Voice Comms is Combined
					if(MicExtToggleCombo) {														// If Mic Toggle ON + Combined External:	Release External PTT Voice Comms Open Comms
						if(VerboseOutput) printf("Voice Comms: <<  BOTH EXTERNAL MICS CLOSED  <<\x0a");
						MicExtToggleCombo = 0;
						if(MicExternalAction & MicExternalActionALT) {							// Depending on the user preferences, release the correct combination of External Voice Comms
							ActKey(KEYON+PULSE+ExternalVoiceCommsPTT);
							ActKey(KEYON+PULSE+ExternalVoiceCommsPTT_ALT); }
						if(!MicExternalAction & MicExternalActionALT) {
							ActKey(KEYON+UP+ExternalVoiceCommsPTT);
							ActKey(KEYON+PULSE+ExternalVoiceCommsPTT_ALT); }
						if(MicExternalAction & !MicExternalActionALT) {
							ActKey(KEYON+PULSE+ExternalVoiceCommsPTT);
							ActKey(KEYON+UP+ExternalVoiceCommsPTT_ALT); }
						if(!MicExternalAction & !MicExternalActionALT) {
							ActKey(KEYON+UP+ExternalVoiceCommsPTT);
							ActKey(KEYON+UP+ExternalVoiceCommsPTT_ALT); } }
					if(MicExtToggleCheck) {														// If Mic Toggle ON + Combined External:	Release External PTT Voice Comms Open Comms
						if(VerboseOutput) printf("Voice Comms: <<  MAIN EXTERNAL MIC CLOSED  <<\x0a");
						if(MicExternalAction)  ActKey(KEYON+PULSE+ExternalVoiceCommsPTT);
						if(!MicExternalAction) ActKey(KEYON+UP+ExternalVoiceCommsPTT);
						MicExtToggleCheck = 0; } }
				if(!ExternalMicCombined) {														// Check if user preference for External Voice Comms is Separate
					if(MicExtToggleCheck) {														// If Mic Toggle ON + Not Combined External:	Release External PTT Voice Comms Open Comms
						if(VerboseOutput) printf("Voice Comms: <<  MAIN EXTERNAL MIC CLOSED  <<\x0a");
						if(MicExternalAction)  ActKey(KEYON+PULSE+ExternalVoiceCommsPTT);
						if(!MicExternalAction) ActKey(KEYON+UP+ExternalVoiceCommsPTT);
						MicExtToggleCheck = 0; }
					if(MicExtToggleCheckALT) {													// If Mic Toggle ON + Not Combined External:	Release Alt. External PTT Voice Comms Open Comms
						if(VerboseOutput) printf("Voice Comms: <<  ALT EXTERNAL MIC CLOSED  <<\x0a");
						if(MicExternalActionALT)  ActKey(KEYON+PULSE+ExternalVoiceCommsPTT_ALT);
						if(!MicExternalActionALT) ActKey(KEYON+UP+ExternalVoiceCommsPTT_ALT);
						MicExtToggleCheckALT = 0; } } } } }


//--------------------------------------------------------------------------------------------------------------------------------------------------------------//
// 5. START-UP: REPORT SCRIPT STATES //
//--------------------------------------------------------------------------------------------------------------------------------------------------------------//

	int initPrintState() {	    			 fnProcessFlags();									 // Display the status of the macro toggles & user prefs on run.
		printf("-----------------------------------------------------------------------------------------------------------------------------------------------\x0a");
		printf(">> ENHANCEMENTS LOADING:	v%d.%d.%d	  TARGET Mappings, Macros & Functions Decrypted			<|>\x0a", ADVersionMajor, ADVersionMinor, ADVersionPoint);
		printf("-----------------------------------------------------------------------------------------------------------------------------------------------\x0a");
		if(VerboseOutput) printf(":....USER PREFERENCES....:\x0a");
		printf("[Run Software @ Start = %d]  [Custom Slider Curve = %d]  [PIP Mgt. Preset = %d]  [MFD Active  = %d]\x0a", StartSoftware, CustomDXSliderCurve, UserPIPPref, UseMFD);
		printf("[Cargo Precision Mode = %d]  [S/Cruise @ Throttle = %d]  [Chaff @ Escape  = %d]  [Boost @ Esc = %d]\x0a", CargoPrecisionMode, CruiseOnThrottle, AutoChaffOnEscape, AutoBoostOnEscape);
		printf("[Combine External Mic = %d]  [Sec. Fire Override  = %d]  [NightVision HUD = %d]  [Ext Mic+Mic = %d]\x0a", ExternalMicCombined, SecFirePinkyPref, NightVisionHUD, ExternalMicCombined);
		printf("[Headtrak Center Mode = %d]  [Ship Utility Mode   = %d]  [LED Backlight = %d]  [LED ¡Bling! = %d]\x0a", HeadtrackPref, ShipUtilityPref, SetLED, BlingLEDBling);
		printf("[Throttle Axis O/ride = %d]  [Joystik Axis O/ride = %d]  [Throttle D/zone = %d]  [Joys D/zone = %d]\x0a", ThrottleOverride, JoystickOverride, TFULL_DEADZONE, JS_DEADZONE);
		if(VerboseOutput) printf("\x0a"); 
		if(VerboseOutput) printf(":..DEFAULT TOGGLE STATE..:\x0a");
		if(VerboseOutput) printf("[Combine Pri+Sec Fire = %d]  [Rot. Correction = %d]  [C/ Scoop = %d]  [L/ Gear = %d]  [Lights  = %d]\x0a", combinePriSecFire, RCorrection, fCargoScoop, fLandingGear, fLights);
		printf("-----------------------------------------------------------------------------------------------------------------------------------------------\x0a");
		if(VerboseOutput) printf("Starting Macros... Compiling Functions... "); }


//--------------------------------------------------------------------------------------------------------------------------------------------------------------//